(function(dImyTP){
const firebaseConfig = { apiKey: "AIzaSyBCLc0MfmOCNMJ4aneEEd4XTPuBZAmWBsE", authDomain: "hamster-7e3ad.firebaseapp.com", projectId: "hamster-7e3ad", storageBucket: "hamster-7e3ad.firebasestorage.app", messagingSenderId: "529569458550", appId: "1:529569458550:web:62819349604236d3ad3257"
};
let db, auth;
try { firebase.initializeApp(firebaseConfig); db = firebase.firestore(); auth = firebase.auth(); console.log('‚úÖ Firebase initialized');
} catch (e) { console.warn('‚ö†Ô∏è Firebase not available, using local storage mode'); db = { collection: () => ({ doc: () => ({ get: async () => ({ exists: false, data: () => ({}) }), set: async () => {} }) }) }; auth = { onAuthStateChanged: (callback) => { setTimeout(() => callback({ uid: 'local-user', email: 'local@test.com' }), 500); }, signInWithEmailAndPassword: async () => ({ user: { uid: 'local-user' } }), createUserWithEmailAndPassword: async () => ({ user: { uid: 'local-user' } }) };
}
const FOX_LEVELS = { 1: { name: "Rookie Fox", xpRequired: 0, image: "images/rookie-fox.png" }, 2: { name: "Starter Fox", xpRequired: 1000, image: "images/starter-fox.png" }, 3: { name: "Rising Fox", xpRequired: 5000, image: "images/rising-fox.png" }, 4: { name: "Office Fox", xpRequired: 25000, image: "images/office-fox.png" }, 5: { name: "Executive Fox", xpRequired: 100000, image: "images/executive-fox.png" }, 6: { name: "Elite Fox", xpRequired: 500000, image: "images/elite-fox.png" }, 7: { name: "Billionaire Fox", xpRequired: 2500000, image: "images/billionaire-fox.png" }, 8: { name: "Platinum Tycoon Fox", xpRequired: 10000000, image: "images/platinum-tycoon-fox.png" }, 9: { name: "Crimson Empire Fox", xpRequired: 50000000, image: "images/crimson-empire-fox.png" }, 10: { name: "Sovereign Fox", xpRequired: 500000000, image: "images/sovereign-fox.png" }
};
const profits = { forest: 5, mountain: 8, valley: 12
};
const unlockPrices = { forest: 1000, mountain: 5000, valley: 10000
};
const upgradeCosts = { forest: 500, mountain: 1000, valley: 2000
};
const XP_RATES = { tap: 1, huntForest: 5, huntMountain: 8, huntValley: 12, achievement: 1000, prestige: 10000, daily: 50
};
const DAILY_REWARDS = [ { day: 1, reward: 500, type: 'coins' }, { day: 2, reward: 1000, type: 'coins' }, { day: 3, reward: 50, type: 'energy' }, { day: 4, reward: 2000, type: 'coins' }, { day: 5, reward: 100, type: 'energy' }, { day: 6, reward: 5000, type: 'coins' }, { day: 7, reward: 10000, type: 'coins' }
];
let currentUser = null;
let currentUserDoc = null;
let userData = { username: 'Fox', email: '', coins: 1000, energy: 500, maxEnergy: 500, tapsTotal: 0, totalEarned: 1000, foxLevel: { level: 1, xp: 0, xpToNextLevel: FOX_LEVELS[2].xpRequired }, prestige: { lives: 0, multiplier: 1 }, huntingGrounds: { forest: { level: 1, unlocked: false }, mountain: { level: 1, unlocked: false }, valley: { level: 1, unlocked: false } }, cosmetics: { glasses: false, hat: false, cape: false }, luckyHunt: { active: false, endTime: 0 }, dailyRewards: { lastClaimDay: 0, streak: 0, lastClaimDate: null, available: true }, weeklyChallenges: { weekStart: Date.now(), challenges: [ { id: 'tap', description: 'Tap 1000 times', progress: 0, target: 1000, completed: false, reward: 5000 }, { id: 'earn', description: 'Earn 10,000 ü¶ä', progress: 0, target: 10000, completed: false, reward: 5000 }, { id: 'unlock', description: 'Unlock 2 hunting grounds', progress: 0, target: 2, completed: false, reward: 5000 }, { id: 'upgrade', description: 'Upgrade any ground 5 times', progress: 0, target: 5, completed: false, reward: 5000 } ], weeklyBonus: false }, achievements: { tapMaster: { progress: 0, target: 10000, completed: false, reward: 10000 }, tapGod: { progress: 0, target: 100000, completed: false, reward: 50000 }, hunterBeginner: { progress: 0, target: 100000, completed: false, reward: 10000 }, hunterExpert: { progress: 0, target: 1000000, completed: false, reward: 50000 }, hunterMaster: { progress: 0, target: 10000000, completed: false, reward: 100000 }, firstLife: { progress: 0, target: 1, completed: false, reward: 20000 }, nineLives: { progress: 0, target: 9, completed: false, reward: 100000 }, fashionista: { progress: 0, target: 3, completed: false, reward: 15000 } }, cashout: { totalWithdrawn: 0, pendingWithdrawals: [], withdrawalHistory: []
},
airdrops: { welcome: { claimed: false, expiresAt: Date.now() + 86400000 * 7 }, dailyBonus: { claimed: false, requirement: 3 }, megaAirdrop: { claimed: false, requirement: 100000 } },
referral: { code: 'FOX' + Math.random().toString(36).substring(2, 8).toUpperCase(), count: 0, earned: 0, referrals: []
}
};
const loginScreen = document.getElementById('loginScreen');
const mainApp = document.getElementById('mainApp');
const loginForm = document.getElementById('loginForm');
const signupForm = document.getElementById('signupForm');
const showLoginBtn = document.getElementById('showLoginBtn');
const showSignupBtn = document.getElementById('showSignupBtn');
const loginBtn = document.getElementById('loginBtn');
const signupBtn = document.getElementById('signupBtn');
const loginEmail = document.getElementById('loginEmail');
const loginPassword = document.getElementById('loginPassword');
const signupUsername = document.getElementById('signupUsername');
const signupEmail = document.getElementById('signupEmail');
const signupPassword = document.getElementById('signupPassword');
const signupConfirmPassword = document.getElementById('signupConfirmPassword');
const loginError = document.getElementById('loginError');
const signupError = document.getElementById('signupError');
const displayUsername = document.getElementById('displayUsername');
const coinDisplay = document.getElementById('coinDisplay');
const tapFox = document.getElementById('tapFox');
const prestigeBadge = document.getElementById('prestigeBadge');
const energyValue = document.getElementById('energyValue');
const energyFill = document.getElementById('energyFill');
const foxLevelBadge = document.getElementById('foxLevelBadge');
const levelFill = document.getElementById('levelFill');
const levelProgressText = document.getElementById('levelProgressText');
const foxEmoji = document.getElementById('foxEmoji');
if (showLoginBtn && showSignupBtn) { showLoginBtn.addEventListener('click', () => { showLoginBtn.classList.add('active'); showSignupBtn.classList.remove('active'); loginForm.classList.remove('hidden'); signupForm.classList.add('hidden'); if (loginError) loginError.textContent = ''; }); showSignupBtn.addEventListener('click', () => { showSignupBtn.classList.add('active'); showLoginBtn.classList.remove('active'); signupForm.classList.remove('hidden'); loginForm.classList.add('hidden'); if (signupError) signupError.textContent = ''; });
}
if (signupBtn) { signupBtn.addEventListener('click', async () => { const username = signupUsername ? signupUsername.value.trim() : ''; const email = signupEmail ? signupEmail.value.trim() : ''; const password = signupPassword ? signupPassword.value.trim() : ''; const confirmPass = signupConfirmPassword ? signupConfirmPassword.value.trim() : ''; const referralCode = document.getElementById('signupReferral')?.value.trim() || ''; if (!username || !email || !password || !confirmPass) { if (signupError) signupError.textContent = 'All fields are required!'; return; } if (password !== confirmPass) { if (signupError) signupError.textContent = 'Passwords do not match!'; return; } if (password.length < 6) { if (signupError) signupError.textContent = 'Password must be at least 6 characters!'; return; } try { if (signupError) signupError.textContent = 'Creating account...'; const userCredential = await auth.createUserWithEmailAndPassword(email, password); const user = userCredential.user; loadLocalSave(); const newReferralCode = 'FOX' + Math.random().toString(36).substring(2, 8).toUpperCase(); const newUserData = { ...userData, username: username, email: email, referral: { code: newReferralCode, count: 0, earned: 0, referrals: [], referredBy: referralCode || null }, createdAt: new Date().toISOString() }; if (referralCode) { newUserData.coins += 500; newUserData.totalEarned += 500; await processReferralBonus(referralCode, user.uid); } if (db.collection) { await db.collection('users').doc(user.uid).set(newUserData); } if (signupError) signupError.textContent = 'Account created! Logging in...'; await loginUser(email, password); } catch (error) { console.error('Signup error:', error); if (signupError) signupError.textContent = error.message; } });
}
async function loginUser(email, password) { try { if (loginError) loginError.textContent = 'Logging in...'; const userCredential = await auth.signInWithEmailAndPassword(email, password); const user = userCredential.user; currentUser = user; loadLocalSave(); console.log('üí∞ Local coins loaded:', userData.coins); if (db.collection) { const doc = await db.collection('users').doc(user.uid).get(); if (doc.exists) { const data = doc.data(); userData = { ...userData, ...data, ...userData }; console.log('üî• Firebase data loaded:', data.coins, 'coins'); console.log('üí∞ Final coins:', userData.coins); } else { await db.collection('users').doc(user.uid).set(userData); } } userData.email = email; userData.username = userData.username || email.split('@')[0]; updateUI(); checkDailyReward(); updateChallengesProgress(); loginScreen.classList.add('hidden'); mainApp.classList.remove('hidden'); startAutoHunter(); startLuckyHuntChecker(); startDailyTimer(); loadLeaderboard(); if (loginError) loginError.textContent = ''; } catch (error) { console.error('Login error:', error); currentUser = { uid: 'demo-user' }; loadLocalSave(); userData.username = userData.username || 'DemoFox'; loginScreen.classList.add('hidden'); mainApp.classList.remove('hidden'); updateUI(); startAutoHunter(); startDailyTimer(); loadLeaderboard(); if (loginError) loginError.textContent = 'Demo mode activated'; }
}
if (auth.onAuthStateChanged) { auth.onAuthStateChanged(async (user) => { if (user) { currentUser = user; loadLocalSave(); if (db.collection) { const doc = await db.collection('users').doc(user.uid).get(); if (doc.exists) { const data = doc.data(); userData = { ...userData, ...data, ...userData }; } } updateUI(); checkDailyReward(); updateChallengesProgress(); loginScreen.classList.add('hidden'); mainApp.classList.remove('hidden'); startAutoHunter(); startLuckyHuntChecker(); startDailyTimer(); loadLeaderboard(); } });
}
const navItems = document.querySelectorAll('.nav-item');
const panels = {};
function initPanels() { const panelIds = ['fox', 'ponds', 'shop', 'prestige', 'cashout', 'daily', 'challenges', 'achievements', 'leaderboard']; panelIds.forEach(id => { panels[id] = document.getElementById(`panel${id.charAt(0).toUpperCase() + id.slice(1)}`); });
}
initPanels();
if (navItems.length > 0) { navItems.forEach(item => { item.addEventListener('click', () => { navItems.forEach(n => n.classList.remove('active')); item.classList.add('active'); const tab = item.dataset.tab; Object.values(panels).forEach(panel => { if (panel) panel.classList.remove('active-panel'); }); if (panels[tab]) { panels[tab].classList.add('active-panel'); if (tab === 'daily') updateDailyUI(); else if (tab === 'challenges') updateChallengesUI(); else if (tab === 'achievements') updateAchievementsUI(); else if (tab === 'leaderboard') loadLeaderboard(); } }); });
}
function updateUI() { if (!currentUser) return; if (displayUsername) displayUsername.textContent = userData.username || 'Fox'; if (coinDisplay) coinDisplay.textContent = Math.floor(userData.coins).toLocaleString(); if (energyValue) energyValue.textContent = `${Math.floor(userData.energy)}/${userData.maxEnergy}`; if (energyFill) energyFill.style.width = `${(userData.energy / userData.maxEnergy) * 100}%`; updateFoxUI(); updateGroundsUI(); updateShopButtons(); updatePrestigeInfo(); updateCashoutUI();
}
function addFoxXP(amount) { userData.foxLevel.xp += amount; while (userData.foxLevel.level < 10 && userData.foxLevel.xp >= FOX_LEVELS[userData.foxLevel.level + 1].xpRequired) { levelUpFox(); } if (userData.foxLevel.level >= 10) { userData.foxLevel.level = 10; userData.foxLevel.xp = FOX_LEVELS[10].xpRequired; } updateFoxUI();
}
function levelUpFox() { userData.foxLevel.level++; const newLevel = userData.foxLevel.level; const levelData = FOX_LEVELS[newLevel]; createFloatingNumber(`ü¶ä LEVEL ${newLevel}!`, 'rainbow'); const levelUpBonus = 1000 * Math.pow(10, newLevel - 1); userData.coins += levelUpBonus; if (foxEmoji) { foxEmoji.src = levelData.image; foxEmoji.alt = levelData.name; } if (newLevel === 10) { alert('üëë LEGENDARY! You have become the SOVEREIGN FOX! üëë'); createFloatingNumber('üëë SOVEREIGN FOX üëë', 'rainbow'); userData.prestige.multiplier *= 3; userData.coins += 10000000; } saveUserData();
}
function updateFoxUI() { const level = userData.foxLevel?.level || 1; const xp = userData.foxLevel?.xp || 0; if (foxLevelBadge) { const levelData = FOX_LEVELS[level]; foxLevelBadge.textContent = `ü¶ä ${levelData.name}`; foxLevelBadge.className = level === 10 ? 'sovereign-badge' : 'fox-level-badge'; } if (foxEmoji) { foxEmoji.src = FOX_LEVELS[level].image; foxEmoji.alt = FOX_LEVELS[level].name; } const nextLevelXP = level < 10 ? FOX_LEVELS[level + 1].xpRequired : FOX_LEVELS[10].xpRequired; const currentLevelXP = level > 1 ? FOX_LEVELS[level].xpRequired : 0; const xpForThisLevel = nextLevelXP - currentLevelXP; const xpProgress = xp - currentLevelXP; const progressPercent = level < 10 ? Math.min((xpProgress / xpForThisLevel) * 100, 100) : 100; if (levelFill) levelFill.style.width = `${progressPercent}%`; if (levelProgressText) { if (level < 10) { levelProgressText.textContent = `${Math.floor(xpProgress).toLocaleString()}/${xpForThisLevel.toLocaleString()} XP`; } else { levelProgressText.textContent = `MAX LEVEL üëë`; } } if (prestigeBadge) prestigeBadge.textContent = `ü¶ä ${level}`;
}
function updateGroundsUI() { const grounds = ['forest', 'mountain', 'valley']; grounds.forEach((ground, index) => { const groundData = userData.huntingGrounds?.[ground] || { level: 1, unlocked: false }; const card = document.getElementById(`ground${index + 1}Card`); const btn = document.getElementById(`ground${index + 1}`); const priceSpan = document.getElementById(`unlockPrice${index + 1}`); const levelSpan = document.getElementById(`groundLvl${index + 1}`); const profitSpan = document.getElementById(`groundProfit${index + 1}`); if (card) { if (groundData.unlocked) { card.classList.remove('locked'); card.classList.add('unlocked'); if (btn) { btn.disabled = false; btn.textContent = 'ü¶ä'; btn.classList.remove('locked-btn'); btn.classList.add('unlocked-btn'); } if (priceSpan) priceSpan.innerHTML = `‚úÖ lvl ${groundData.level}`; } else { card.classList.add('locked'); card.classList.remove('unlocked'); if (btn) { btn.disabled = false; btn.textContent = 'üîì UNLOCK'; btn.classList.add('locked-btn'); btn.classList.remove('unlocked-btn'); } if (priceSpan) priceSpan.innerHTML = `üîí ${unlockPrices[ground].toLocaleString()}`; } if (levelSpan) levelSpan.textContent = groundData.level; if (profitSpan) profitSpan.textContent = groundData.level * profits[ground]; } });
}
['ground1', 'ground2', 'ground3'].forEach((id, index) => { const btn = document.getElementById(id); if (btn) { btn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); const grounds = ['forest', 'mountain', 'valley']; const ground = grounds[index]; console.log(`üîò Clicked ${ground} button`); handleGroundClick(ground); }); }
});
['ground1Card', 'ground2Card', 'ground3Card'].forEach((id, index) => { const card = document.getElementById(id); if (card) { card.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') return; const grounds = ['forest', 'mountain', 'valley']; const ground = grounds[index]; console.log(`üÉè Clicked ${ground} card`); handleGroundClick(ground); }); }
});
function handleGroundClick(ground) { if (!currentUser) { alert('Please login first'); return; } console.log('üéØ Handling click for:', ground); console.log('Current state:', userData.huntingGrounds[ground]); if (userData.huntingGrounds[ground]?.unlocked) { huntGround(ground); } else { unlockGround(ground); }
}
function unlockGround(ground) { const price = unlockPrices[ground]; console.log('üí∞ Attempting to unlock:', ground); console.log('üí∞ Current coins:', userData.coins, 'Price:', price); console.log('üí∞ Has enough:', userData.coins >= price); if (userData.coins < price) { alert(`‚ùå Need ${price.toLocaleString()} ü¶ä to unlock ${ground}! You have ${Math.floor(userData.coins).toLocaleString()}`); return; } userData.coins -= price; userData.huntingGrounds[ground].unlocked = true; console.log('‚úÖ Unlocked! New coins:', userData.coins); createFloatingNumber(-price); updateUI(); saveUserData(); updateChallengeProgress('unlock', 1); alert(`üéâ ${ground.toUpperCase()} GROUND UNLOCKED! You can now hunt here!`);
}
function huntGround(ground) { if (userData.energy < 10) { alert('‚ùå Need 10 energy to hunt!'); return; } const level = userData.huntingGrounds[ground]?.level || 1; let reward = level * profits[ground] * (userData.prestige?.multiplier || 1); if (userData.luckyHunt?.active) { reward *= 10; } userData.coins += reward; userData.totalEarned += reward; userData.energy -= 10; userData.tapsTotal++; addFoxXP(XP_RATES[`hunt${ground.charAt(0).toUpperCase() + ground.slice(1)}`] || XP_RATES.tap); createFloatingNumber(reward); updateChallengeProgress('earn', reward); if (Math.random() < 0.01 && !userData.luckyHunt?.active) { activateLuckyHunt(); } updateUI(); saveUserData();
}
const upgradeForest = document.getElementById('upgradeForestBtn');
const upgradeMountain = document.getElementById('upgradeMountainBtn');
const upgradeValley = document.getElementById('upgradeValleyBtn');
if (upgradeForest) upgradeForest.addEventListener('click', () => upgradeGround('forest'));
if (upgradeMountain) upgradeMountain.addEventListener('click', () => upgradeGround('mountain'));
if (upgradeValley) upgradeValley.addEventListener('click', () => upgradeGround('valley'));
function upgradeGround(ground) { if (!userData.huntingGrounds[ground]?.unlocked) { alert(`‚ùå Unlock the ${ground} first!`); return; } const cost = upgradeCosts[ground] * Math.pow(1.5, userData.huntingGrounds[ground].level - 1); if (userData.coins < cost) { alert(`‚ùå Need ${Math.floor(cost).toLocaleString()} ü¶ä to upgrade!`); return; } userData.coins -= cost; userData.huntingGrounds[ground].level++; addFoxXP(50); createFloatingNumber(-cost); updateUI(); saveUserData(); updateChallengeProgress('upgrade', 1); alert(`‚¨ÜÔ∏è ${ground.toUpperCase()} upgraded to level ${userData.huntingGrounds[ground].level}!`);
}
function updateShopButtons() { const items = ['glasses', 'hat', 'cape']; items.forEach(item => { const btn = document.getElementById(`${item}Btn`); if (btn) { if (userData.cosmetics?.[item]) { btn.textContent = '‚úì OWNED'; btn.classList.add('owned'); btn.disabled = true; } else { const prices = { glasses: '5K', hat: '10K', cape: '25K' }; btn.textContent = `${prices[item]} ü¶ä`; btn.classList.remove('owned'); btn.disabled = false; } } });
}
const glassesBtn = document.getElementById('glassesBtn');
const hatBtn = document.getElementById('hatBtn');
const capeBtn = document.getElementById('capeBtn');
if (glassesBtn) glassesBtn.addEventListener('click', () => buyItem('glasses', 5000));
if (hatBtn) hatBtn.addEventListener('click', () => buyItem('hat', 10000));
if (capeBtn) capeBtn.addEventListener('click', () => buyItem('cape', 25000));
function buyItem(item, price) { if (userData.cosmetics[item]) { alert('Already owned!'); return; } if (userData.coins < price) { alert(`‚ùå Need ${price.toLocaleString()} ü¶ä!`); return; } userData.coins -= price; userData.cosmetics[item] = true; const element = document.getElementById(`fox${item.charAt(0).toUpperCase() + item.slice(1)}`); if (element) element.classList.add('active'); addFoxXP(100); createFloatingNumber(-price); updateUI(); saveUserData(); alert(`üéâ ${item} purchased!`);
}
if (tapFox) { tapFox.addEventListener('click', () => { if (!currentUser) return; if (userData.energy < 1) { alert('‚ö° No energy!'); return; } let tapValue = 1 * (userData.prestige?.multiplier || 1); if (userData.luckyHunt?.active) { tapValue *= 10; } userData.coins += tapValue; userData.totalEarned += tapValue; if (currentUser) { updateReferralEarnings(currentUser.uid, tapValue); } userData.energy -= 1; userData.tapsTotal++; addFoxXP(XP_RATES.tap); createFloatingNumber(tapValue); updateChallengeProgress('tap', 1); updateChallengeProgress('earn', tapValue); checkAchievements(); if (Math.random() < 0.01 && !userData.luckyHunt?.active) { activateLuckyHunt(); } tapFox.style.transform = 'scale(0.9) rotate(-2deg)'; setTimeout(() => { tapFox.style.transform = ''; }, 100); updateUI(); saveUserData(); });
}
function activateLuckyHunt() { userData.luckyHunt.active = true; userData.luckyHunt.endTime = Date.now() + 10000; const luckyHunt = document.getElementById('luckyHunt'); if (luckyHunt) luckyHunt.classList.remove('hidden'); const timer = setInterval(() => { const remaining = Math.max(0, userData.luckyHunt.endTime - Date.now()); const seconds = Math.ceil(remaining / 1000); const luckyTimer = document.getElementById('luckyTimer'); if (luckyTimer) luckyTimer.textContent = `${seconds}s`; if (remaining <= 0) { userData.luckyHunt.active = false; if (luckyHunt) luckyHunt.classList.add('hidden'); clearInterval(timer); } }, 100);
}
function startLuckyHuntChecker() { setInterval(() => { if (userData.luckyHunt.active && Date.now() > userData.luckyHunt.endTime) { userData.luckyHunt.active = false; const luckyHunt = document.getElementById('luckyHunt'); if (luckyHunt) luckyHunt.classList.add('hidden'); } }, 100);
}
function updatePrestigeInfo() { const livesSpan = document.getElementById('prestigeLives'); const multiSpan = document.getElementById('prestigeMultiplier'); const nextSpan = document.getElementById('nextPrestige'); const progressBar = document.getElementById('prestigeProgress'); if (livesSpan) livesSpan.textContent = userData.prestige?.lives || 0; if (multiSpan) multiSpan.textContent = `${userData.prestige?.multiplier || 1}x`; const nextPrestige = 100000 * Math.pow(2, userData.prestige?.lives || 0); if (nextSpan) nextSpan.textContent = `${nextPrestige.toLocaleString()} ü¶ä`; const progress = ((userData.totalEarned || 0) / nextPrestige) * 100; if (progressBar) progressBar.style.width = `${Math.min(progress, 100)}%`;
}
const prestigeBtn = document.getElementById('prestigeBtn');
if (prestigeBtn) { prestigeBtn.addEventListener('click', () => { if (!currentUser) return; const nextPrestige = 100000 * Math.pow(2, userData.prestige.lives); if (userData.totalEarned < nextPrestige) { alert(`‚ùå Need ${nextPrestige.toLocaleString()} total ü¶ä!`); return; } if (userData.prestige.lives >= 9) { alert('üåü MAX LIVES REACHED!'); return; } const confirmed = confirm('Prestige will reset your progress but give 2x multiplier! Continue?'); if (confirmed) { userData.prestige.lives++; userData.prestige.multiplier *= 2; userData.coins = 1000; userData.totalEarned = 1000; userData.huntingGrounds = { forest: { level: 1, unlocked: false }, mountain: { level: 1, unlocked: false }, valley: { level: 1, unlocked: false } }; userData.cosmetics = { glasses: false, hat: false, cape: false }; userData.foxLevel = { level: 1, xp: 0, xpToNextLevel: FOX_LEVELS[2].xpRequired }; if (foxEmoji) foxEmoji.textContent = 'ü¶ä'; addFoxXP(XP_RATES.prestige); updateUI(); saveUserData(); alert(`üåü PRESTIGE ${userData.prestige.lives}! Multiplier: ${userData.prestige.multiplier}x`); } });
}
function startAutoHunter() { setInterval(() => { if (!currentUser || !mainApp || mainApp.classList.contains('hidden')) return; let totalHunted = 0; Object.keys(userData.huntingGrounds).forEach(ground => { if (userData.huntingGrounds[ground]?.unlocked) { const level = userData.huntingGrounds[ground]?.level || 1; const baseProfit = profits[ground] || 5; totalHunted += (level * baseProfit) / 10; } }); if (totalHunted > 0) { totalHunted *= (userData.prestige?.multiplier || 1); userData.coins += totalHunted; userData.totalEarned += totalHunted; if (currentUser) { updateReferralEarnings(currentUser.uid, totalHunted); } updateChallengeProgress('earn', totalHunted); updateUI();
} if (userData.energy < userData.maxEnergy) { userData.energy = Math.min(userData.energy + 1, userData.maxEnergy); updateUI(); } if (Math.random() < 0.03) { saveUserData(); } }, 1000);
}
function checkDailyReward() { const today = new Date().toDateString(); const lastClaim = userData.dailyRewards.lastClaimDate; console.log('üìÖ Checking daily - Today:', today, 'Last:', lastClaim); if (!lastClaim) { userData.dailyRewards.available = true; userData.dailyRewards.streak = 1; userData.dailyRewards.lastClaimDay = 0; console.log('üìÖ First time - streak 1'); } else if (lastClaim !== today) { const lastDate = new Date(lastClaim); const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); if (lastDate.toDateString() === yesterday.toDateString()) { userData.dailyRewards.streak = Math.min((userData.dailyRewards.streak || 0) + 1, 7); console.log('üìÖ Consecutive - streak:', userData.dailyRewards.streak); } else { userData.dailyRewards.streak = 1; console.log('üìÖ Streak broken - reset to 1'); } userData.dailyRewards.available = true; userData.dailyRewards.lastClaimDay = (userData.dailyRewards.streak - 1) % 7; } else { userData.dailyRewards.available = false; console.log('üìÖ Already claimed today'); } updateDailyUI(); saveUserData();
}
const claimDailyBtn = document.getElementById('claimDailyBtn');
if (claimDailyBtn) { claimDailyBtn.addEventListener('click', () => { if (!userData.dailyRewards.available) { alert('Already claimed today! Come back tomorrow!'); return; } const dayIndex = userData.dailyRewards.streak - 1; const reward = DAILY_REWARDS[dayIndex]; if (reward.type === 'coins') { userData.coins += reward.reward; createFloatingNumber(reward.reward, 'gold'); } else if (reward.type === 'energy') { userData.energy = Math.min(userData.energy + reward.reward, userData.maxEnergy); } addFoxXP(XP_RATES.daily * userData.dailyRewards.streak); userData.dailyRewards.lastClaimDate = new Date().toDateString(); userData.dailyRewards.available = false; if (userData.dailyRewards.streak === 7) { userData.weeklyChallenges.weeklyBonus = true; userData.coins += 20000; createFloatingNumber(20000, 'rainbow'); alert('üéâ WEEKLY BONUS! +20,000 ü¶ä'); } updateDailyUI(); saveUserData(); });
}
function updateDailyUI() { const streak = userData.dailyRewards.streak; const grid = document.getElementById('dailyGrid'); const currentStreakEl = document.getElementById('currentStreak'); const bonusBar = document.getElementById('bonusBar'); if (currentStreakEl) currentStreakEl.textContent = streak; if (bonusBar) bonusBar.style.width = `${(streak / 7) * 100}%`; if (!grid) return; let html = ''; for (let i = 0; i < 7; i++) { const reward = DAILY_REWARDS[i]; const isCompleted = i < streak; const isCurrent = i === streak - 1 && userData.dailyRewards.available; html += ` <div class="daily-box ${isCompleted ? 'completed' : ''} ${isCurrent ? 'current' : ''}"> <div class="day">Day ${i + 1}</div> <div class="reward">${reward.reward} ${reward.type === 'coins' ? 'ü¶ä' : '‚ö°'}</div> ${isCompleted ? '<div class="check">‚úì</div>' : ''} </div> `; } grid.innerHTML = html;
}
function startDailyTimer() { setInterval(() => { const now = new Date(); const tomorrow = new Date(now); tomorrow.setDate(tomorrow.getDate() + 1); tomorrow.setHours(0, 0, 0, 0); const diff = tomorrow - now; const hours = Math.floor(diff / (1000 * 60 * 60)); const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60)); const seconds = Math.floor((diff % (1000 * 60)) / 1000); const nextReset = document.getElementById('nextReset'); if (nextReset) { nextReset.textContent = `Next reset in: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; } if (hours === 0 && minutes === 0 && seconds === 0) { checkDailyReward(); } }, 1000);
}
function updateChallengeProgress(challengeId, amount) { if (!userData.weeklyChallenges) return; const challenge = userData.weeklyChallenges.challenges.find(c => c.id === challengeId); if (!challenge || challenge.completed) return; challenge.progress = Math.min(challenge.progress + amount, challenge.target); console.log(`üéØ Challenge ${challengeId}: ${challenge.progress}/${challenge.target}`); if (challenge.progress >= challenge.target && !challenge.completed) { challenge.completed = true; userData.coins += challenge.reward; createFloatingNumber(challenge.reward, 'gold'); addFoxXP(200); alert(`üéØ CHALLENGE COMPLETE! +${challenge.reward} ü¶ä`); const allCompleted = userData.weeklyChallenges.challenges.every(c => c.completed); if (allCompleted && !userData.weeklyChallenges.weeklyBonus) { userData.weeklyChallenges.weeklyBonus = true; userData.coins += 20000; createFloatingNumber(20000, 'rainbow'); alert('üéâ ALL CHALLENGES COMPLETE! +20,000 ü¶ä'); } } updateChallengesUI(); saveUserData();
}
function updateChallengesUI() { const list = document.getElementById('challengesList'); if (!list) return; let html = ''; userData.weeklyChallenges.challenges.forEach(challenge => { const percent = (challenge.progress / challenge.target) * 100; html += ` <div class="challenge-card ${challenge.completed ? 'completed' : ''}"> <div class="challenge-info"> <span class="challenge-desc">${challenge.description}</span> <span class="challenge-progress">${challenge.progress}/${challenge.target}</span> </div> <div class="challenge-bar-bg"> <div class="challenge-bar-fill" style="width: ${percent}%"></div> </div> <div class="challenge-reward">üéÅ ${challenge.reward} ü¶ä</div> ${challenge.completed ? '<div class="challenge-check">‚úì</div>' : ''} </div> `; }); list.innerHTML = html;
}
function updateChallengesProgress() { const unlockedCount = Object.values(userData.huntingGrounds).filter(g => g.unlocked).length; updateChallengeProgress('unlock', 0); updateChallengeProgress('tap', 0); updateChallengeProgress('earn', 0); updateChallengeProgress('upgrade', 0);
}
function updateAchievementsUI() { const grid = document.getElementById('achievementsGrid'); const achievementCount = document.getElementById('achievementCount'); const totalAchievements = document.getElementById('totalAchievements'); if (!grid) return; const achievementNames = { tapMaster: 'ü¶ä Tap Master', tapGod: 'üëë Tap God', hunterBeginner: 'ü¶ä Hunter Beginner', hunterExpert: 'üèπ Hunter Expert', hunterMaster: 'üëë Hunter Master', firstLife: 'üåü First Life', nineLives: 'ü¶ä Nine Lives', fashionista: 'üëó Fashionista' }; let html = ''; let completedCount = 0; Object.keys(userData.achievements).forEach(key => { const ach = userData.achievements[key]; if (ach.completed) completedCount++; const percent = (ach.progress / ach.target) * 100; html += ` <div class="achievement-card ${ach.completed ? 'completed' : ''}"> <div class="achievement-icon">${achievementNames[key]?.split(' ')[0] || 'üèÜ'}</div> <div class="achievement-info"> <div class="achievement-name">${achievementNames[key] || key}</div> <div class="achievement-progress">${ach.progress.toLocaleString()}/${ach.target.toLocaleString()}</div> <div class="achievement-bar-bg"> <div class="achievement-bar-fill" style="width: ${percent}%"></div> </div> <div class="achievement-reward">üéÅ ${ach.reward} ü¶ä</div> </div> </div> `; }); grid.innerHTML = html; if (achievementCount) achievementCount.textContent = completedCount; if (totalAchievements) totalAchievements.textContent = Object.keys(userData.achievements).length;
}
function checkAchievements() { const a = userData.achievements; a.tapMaster.progress = userData.tapsTotal; if (userData.tapsTotal >= 10000 && !a.tapMaster.completed) completeAchievement('tapMaster'); a.tapGod.progress = userData.tapsTotal; if (userData.tapsTotal >= 100000 && !a.tapGod.completed) completeAchievement('tapGod'); a.hunterBeginner.progress = userData.totalEarned; if (userData.totalEarned >= 100000 && !a.hunterBeginner.completed) completeAchievement('hunterBeginner'); a.hunterExpert.progress = userData.totalEarned; if (userData.totalEarned >= 1000000 && !a.hunterExpert.completed) completeAchievement('hunterExpert'); a.hunterMaster.progress = userData.totalEarned; if (userData.totalEarned >= 10000000 && !a.hunterMaster.completed) completeAchievement('hunterMaster'); a.firstLife.progress = userData.prestige.lives; if (userData.prestige.lives >= 1 && !a.firstLife.completed) completeAchievement('firstLife'); a.nineLives.progress = userData.prestige.lives; if (userData.prestige.lives >= 9 && !a.nineLives.completed) completeAchievement('nineLives'); const ownedCosmetics = Object.values(userData.cosmetics).filter(v => v).length; a.fashionista.progress = ownedCosmetics; if (ownedCosmetics >= 3 && !a.fashionista.completed) completeAchievement('fashionista'); updateAchievementsUI();
}
function completeAchievement(id) { const ach = userData.achievements[id]; if (!ach || ach.completed) return; ach.completed = true; userData.coins += ach.reward; addFoxXP(XP_RATES.achievement); createFloatingNumber(ach.reward, 'rainbow'); alert(`üèÜ ACHIEVEMENT UNLOCKED! +${ach.reward} ü¶ä`); saveUserData();
}
async function loadLeaderboard() { const leaderboardList = document.getElementById('leaderboardList'); const yourRank = document.getElementById('yourRank'); if (!leaderboardList) return; try { if (db.collection) { const snapshot = await db.collection('users') .orderBy('totalEarned', 'desc') .limit(10) .get(); if (snapshot.empty) { leaderboardList.innerHTML = '<div class="leaderboard-item">No players yet!</div>'; return; } let html = ''; let rank = 1; snapshot.forEach(doc => { const data = doc.data(); const username = data.username || 'Anonymous'; const totalEarned = data.totalEarned || 0; const foxLevel = data.foxLevel?.level || 1; let rankEmoji = rank === 1 ? 'üëë ' : rank === 2 ? 'ü•à ' : rank === 3 ? 'ü•â ' : ''; const isCurrentUser = currentUser && doc.id === currentUser.uid; html += ` <div class="leaderboard-item ${rank <= 3 ? `top-${rank}` : ''} ${isCurrentUser ? 'current-user' : ''}"> <span>${rankEmoji}${rank}. ${username}</span> <span>Lv.${foxLevel} | ${totalEarned.toLocaleString()} ü¶ä</span> </div> `; rank++; }); leaderboardList.innerHTML = html; } else { leaderboardList.innerHTML = ` <div class="leaderboard-item top-1"><span>üëë 1. FoxMaster</span><span>Lv.9 | 1.2M ü¶ä</span></div> <div class="leaderboard-item top-2"><span>ü•à 2. CryptoFox</span><span>Lv.7 | 850K ü¶ä</span></div> <div class="leaderboard-item top-3"><span>ü•â 3. NineTails</span><span>Lv.6 | 500K ü¶ä</span></div> <div class="leaderboard-item current-user"><span>4. ${userData.username}</span><span>Lv.${userData.foxLevel.level} | ${userData.totalEarned.toLocaleString()} ü¶ä</span></div> `; } if (yourRank) { yourRank.textContent = `ü¶ä Level ${userData.foxLevel.level} ¬∑ ${userData.totalEarned.toLocaleString()} ü¶ä`; } } catch (error) { console.error('Leaderboard error:', error); leaderboardList.innerHTML = '<div class="leaderboard-item">Error loading leaderboard</div>'; }
}
async function saveUserData() { if (!currentUser) { localStorage.setItem('Vulpes_Tycoon_save', JSON.stringify(userData)); console.log('üíæ Saved to localStorage:', userData.coins, 'coins'); return; } try { if (db.collection) { const dataToSave = { username: userData.username, email: userData.email, coins: userData.coins, energy: userData.energy, maxEnergy: userData.maxEnergy, tapsTotal: userData.tapsTotal, totalEarned: userData.totalEarned, foxLevel: userData.foxLevel, prestige: userData.prestige, huntingGrounds: userData.huntingGrounds, cosmetics: userData.cosmetics, dailyRewards: userData.dailyRewards, weeklyChallenges: userData.weeklyChallenges, achievements: userData.achievements, cashout: userData.cashout, airdrops: userData.airdrops, referral: userData.referral, lastActive: new Date().toISOString()
}; await db.collection('users').doc(currentUser.uid).set(dataToSave, { merge: true }); console.log('üî• Saved to Firebase:', userData.coins, 'coins'); } localStorage.setItem('Vulpes_Tycoon_save', JSON.stringify(userData)); } catch (error) { console.error('Save error:', error); localStorage.setItem('Vulpes_Tycoon_save', JSON.stringify(userData)); }
}
function createFloatingNumber(value, color = 'gold') { const container = document.getElementById('floatingNumbers'); if (!container) return; const number = document.createElement('div'); number.className = 'floating-number'; number.textContent = typeof value === 'number' ? `+${Math.floor(value)}ü¶ä` : value; number.style.left = `${Math.random() * 80 + 10}%`; number.style.color = color === 'gold' ? '#ffb347' : color === 'rainbow' ? '#ff6b6b' : color; container.appendChild(number); setTimeout(() => number.remove(), 1500);
}
function loadLocalSave() { const saved = localStorage.getItem('Vulpes_Tycoon_save'); if (saved) { try { const parsed = JSON.parse(saved); userData = { ...userData, ...parsed, foxLevel: { ...userData.foxLevel, ...parsed.foxLevel }, prestige: { ...userData.prestige, ...parsed.prestige }, huntingGrounds: { forest: { ...userData.huntingGrounds.forest, ...parsed.huntingGrounds?.forest }, mountain: { ...userData.huntingGrounds.mountain, ...parsed.huntingGrounds?.mountain }, valley: { ...userData.huntingGrounds.valley, ...parsed.huntingGrounds?.valley } }, cosmetics: { ...userData.cosmetics, ...parsed.cosmetics }, dailyRewards: { ...userData.dailyRewards, ...parsed.dailyRewards }, weeklyChallenges: { ...userData.weeklyChallenges, ...parsed.weeklyChallenges }, achievements: { ...userData.achievements, ...parsed.achievements } }; console.log('‚úÖ Local save loaded:', userData.coins, 'coins'); } catch (e) { console.warn('Failed to load save'); } }
}
function addUnlockButtonStyles() { const style = document.createElement('style'); style.textContent = ` .ground-btn.locked-btn { background: #4CAF50; color: white; width: auto; padding: 0 15px; border-radius: 30px; font-size: 14px; font-weight: bold; box-shadow: 0 4px 0 #2d6a2d; } .ground-btn.unlocked-btn { background: #ffb347; width: 46px; border-radius: 50%; font-size: 24px; } .ground-card { cursor: pointer; transition: all 0.2s; } .ground-card:hover { transform: scale(1.02); border-color: #ffb347; } `; document.head.appendChild(style);
}
document.addEventListener('DOMContentLoaded', () => { console.log('ü¶ä Vulpes Tycoon starting...'); addUnlockButtonStyles(); loadLocalSave(); console.log('üí∞ Starting coins:', userData.coins); const defaultTab = document.querySelector('[data-tab="fox"]'); if (defaultTab) { defaultTab.classList.add('active'); if (panels.fox) panels.fox.classList.add('active-panel'); } setTimeout(() => { updateUI(); updateChallengesProgress(); if (userData.cosmetics.glasses) document.getElementById('foxGlasses')?.classList.add('active'); if (userData.cosmetics.hat) document.getElementById('foxHat')?.classList.add('active'); if (userData.cosmetics.cape) document.getElementById('foxCape')?.classList.add('active'); console.log('‚úÖ UI updated with', userData.coins, 'coins'); }, 100); setInterval(() => { if (currentUser) { saveUserData(); } }, 30000); window.addEventListener('beforeunload', () => { if (currentUser) { localStorage.setItem('Vulpes_Tycoon_save', JSON.stringify(userData)); } });
});
function updateCashoutUI() { const balanceEl = document.getElementById('cashoutBalance'); const usdEl = document.getElementById('usdValue'); const referralCodeEl = document.getElementById('referralCode'); const referralCountEl = document.getElementById('referralCount'); const referralEarnedEl = document.getElementById('referralEarned'); if (balanceEl) balanceEl.textContent = `${Math.floor(userData.coins).toLocaleString()} ü¶ä`; if (usdEl) { const usdValue = (userData.coins / 500000).toFixed(2); usdEl.textContent = `‚âà $${usdValue} USD`; } if (referralCodeEl) referralCodeEl.textContent = userData.referral.code; if (referralCountEl) referralCountEl.textContent = userData.referral.count; if (referralEarnedEl) referralEarnedEl.textContent = `${userData.referral.earned.toLocaleString()} ü¶ä`; updateAirdropButtons(); updateWithdrawalHistory();
}
function updateAirdropButtons() { const airdrop1Btn = document.getElementById('claimAirdrop1'); const airdrop2Btn = document.getElementById('claimAirdrop2'); const airdrop3Btn = document.getElementById('claimAirdrop3'); const airdropTimer1 = document.getElementById('airdropTimer1'); if (airdrop1Btn) { if (userData.airdrops.welcome.claimed) { airdrop1Btn.textContent = 'CLAIMED ‚úì'; airdrop1Btn.disabled = true; airdrop1Btn.classList.add('claimed'); } else { airdrop1Btn.textContent = 'CLAIM'; airdrop1Btn.disabled = false; airdrop1Btn.classList.remove('claimed'); } } if (airdropTimer1 && !userData.airdrops.welcome.claimed) { const timeLeft = Math.max(0, userData.airdrops.welcome.expiresAt - Date.now()); const hours = Math.floor(timeLeft / (1000 * 60 * 60)); const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60)); const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000); airdropTimer1.textContent = `Expires in: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; } if (airdrop2Btn) { if (userData.airdrops.dailyBonus.claimed) { airdrop2Btn.textContent = 'CLAIMED ‚úì'; airdrop2Btn.disabled = true; airdrop2Btn.classList.add('claimed'); } else { const streak = userData.dailyRewards.streak || 0; if (streak >= 3) { airdrop2Btn.textContent = 'CLAIM'; airdrop2Btn.disabled = false; } else { airdrop2Btn.textContent = `Need ${3 - streak} more days`; airdrop2Btn.disabled = true; } } } if (airdrop3Btn) { if (userData.airdrops.megaAirdrop.claimed) { airdrop3Btn.textContent = 'CLAIMED ‚úì'; airdrop3Btn.disabled = true; airdrop3Btn.classList.add('claimed'); } else { if (userData.totalEarned >= 100000) { airdrop3Btn.textContent = 'CLAIM'; airdrop3Btn.disabled = false; } else { airdrop3Btn.textContent = `Need ${(100000 - userData.totalEarned).toLocaleString()} more`; airdrop3Btn.disabled = true; } } }
}
function claimAirdrop(type, amount) { if (userData.airdrops[type].claimed) { alert('You already claimed this airdrop!'); return; } if (type === 'dailyBonus' && (userData.dailyRewards.streak || 0) < 3) { alert('Need 3 day streak to claim this airdrop!'); return; } if (type === 'megaAirdrop' && userData.totalEarned < 100000) { alert('Need 100,000 total ü¶ä to claim this airdrop!'); return; } if (type === 'welcome' && Date.now() > userData.airdrops.welcome.expiresAt) { alert('This airdrop has expired!'); return; } userData.airdrops[type].claimed = true; userData.coins += amount; userData.totalEarned += amount; createFloatingNumber(amount, 'rainbow'); alert(`üéâ Claimed ${amount} ü¶ä from ${type} airdrop!`); updateCashoutUI(); updateUI(); saveUserData();
}
function handleWithdrawal() { const amountInput = document.getElementById('withdrawAmount'); const method = document.getElementById('withdrawMethod'); const address = document.getElementById('withdrawAddress'); const errorEl = document.getElementById('withdrawalError'); const amount = parseInt(amountInput?.value); const selectedMethod = method?.value; const walletAddress = address?.value.trim(); if (!amount || amount < 10000) { errorEl.textContent = 'Minimum withdrawal is 10,000 ü¶ä'; return; } if (amount > userData.coins) { errorEl.textContent = 'Insufficient balance'; return; } if (!walletAddress) { errorEl.textContent = 'Please enter your wallet address/email'; return; } const fee = Math.floor(amount * 0.05); const receiveAmount = amount - fee; if (!confirm(`Withdraw ${amount.toLocaleString()} ü¶ä?\nFee: ${fee.toLocaleString()} ü¶ä (5%)\nYou will receive: ${receiveAmount.toLocaleString()} ü¶ä`)) { return; } userData.coins -= amount; userData.cashout.totalWithdrawn += amount; const withdrawal = { id: Date.now(), amount: amount, receiveAmount: receiveAmount, method: selectedMethod, address: walletAddress, status: 'pending', timestamp: new Date().toISOString() }; userData.cashout.pendingWithdrawals.push(withdrawal); userData.cashout.withdrawalHistory.unshift(withdrawal); createFloatingNumber(-amount, 'red'); alert(`‚úÖ Withdrawal request submitted!`); amountInput.value = ''; address.value = ''; errorEl.textContent = ''; updateWithdrawalHistory(); updateCashoutUI(); updateUI(); saveUserData(); setTimeout(() => { withdrawal.status = 'completed'; updateWithdrawalHistory(); saveUserData(); }, 5000);
}
function updateWithdrawalPreview() { const amountInput = document.getElementById('withdrawAmount'); const receiveEl = document.getElementById('receiveAmount'); if (amountInput && receiveEl) { const amount = parseInt(amountInput.value) || 0; const fee = Math.floor(amount * 0.05); const receive = amount - fee; receiveEl.textContent = `${receive.toLocaleString()} ü¶ä`; }
}
function updateWithdrawalHistory() { const historyEl = document.getElementById('withdrawalList'); if (!historyEl) return; if (!userData.cashout.withdrawalHistory || userData.cashout.withdrawalHistory.length === 0) { historyEl.innerHTML = '<div class="history-item">No withdrawals yet</div>'; return; } let html = ''; userData.cashout.withdrawalHistory.slice(0, 5).forEach(w => { const date = new Date(w.timestamp).toLocaleDateString(); const statusEmoji = w.status === 'completed' ? '‚úÖ' : w.status === 'pending' ? '‚è≥' : '‚ùå'; html += ` <div class="history-item"> <span>${date}</span> <span>${w.amount.toLocaleString()} ü¶ä</span> <span>${statusEmoji}</span> </div> `; }); historyEl.innerHTML = html;
}
function startAirdropTimer() { setInterval(() => { if (!mainApp.classList.contains('hidden') && document.getElementById('panelCashout')?.classList.contains('active-panel')) { updateAirdropButtons(); } }, 1000);
}
document.addEventListener('DOMContentLoaded', function() { document.getElementById('claimAirdrop1')?.addEventListener('click', () => claimAirdrop('welcome', 100)); document.getElementById('claimAirdrop2')?.addEventListener('click', () => claimAirdrop('dailyBonus', 500)); document.getElementById('claimAirdrop3')?.addEventListener('click', () => claimAirdrop('megaAirdrop', 10000)); document.getElementById('withdrawBtn')?.addEventListener('click', handleWithdrawal); document.getElementById('withdrawAmount')?.addEventListener('input', updateWithdrawalPreview); document.getElementById('copyReferral')?.addEventListener('click', () => { navigator.clipboard.writeText(userData.referral.code).then(() => { alert('Referral code copied!'); }); }); startAirdropTimer();
});
async function processReferralBonus(referralCode, newUserId) { try { if (!db.collection) { console.log('Demo mode: Referral bonus simulated'); return; } const usersRef = db.collection('users'); const snapshot = await usersRef.where('referral.code', '==', referralCode).get(); if (!snapshot.empty) { const referrerDoc = snapshot.docs[0]; const referrerData = referrerDoc.data(); const updatedReferrals = referrerData.referral?.referrals || []; updatedReferrals.push({ userId: newUserId, joinedAt: new Date().toISOString(), totalEarned: 0 }); await usersRef.doc(referrerDoc.id).update({ 'referral.count': (referrerData.referral?.count || 0) + 1, 'referral.referrals': updatedReferrals, coins: (referrerData.coins || 0) + 500 }); console.log('‚úÖ Referral bonus processed!'); } } catch (error) { console.error('Error processing referral:', error); }
}
async function updateReferralEarnings(friendUserId, amountEarned) { try { if (!db.collection) return; const userDoc = await db.collection('users').doc(friendUserId).get(); const userData = userDoc.data(); if (userData.referral?.referredBy) { const referralCode = userData.referral.referredBy; const usersRef = db.collection('users'); const snapshot = await usersRef.where('referral.code', '==', referralCode).get(); if (!snapshot.empty) { const referrerDoc = snapshot.docs[0]; const referrerData = referrerDoc.data(); const commission = Math.floor(amountEarned * 0.1); await usersRef.doc(referrerDoc.id).update({ 'referral.earned': (referrerData.referral?.earned || 0) + commission, coins: (referrerData.coins || 0) + commission }); const referrals = referrerData.referral?.referrals || []; const updatedReferrals = referrals.map(r => { if (r.userId === friendUserId) { r.totalEarned = (r.totalEarned || 0) + amountEarned; } return r; }); await usersRef.doc(referrerDoc.id).update({ 'referral.referrals': updatedReferrals }); } } } catch (error) { console.error('Error updating referral earnings:', error); }
}})('uRVCmLhN');